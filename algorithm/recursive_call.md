# 재귀함수 Recursive call
자기 자신을 호출하여 순환 수행하는 것!<br>
but! 호출보단 이동의 느낌<br>
각각의 메모리에 할당되는 것이다<br>
함수안에 함수가 있다고 생각하면 안됨!

가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입 선출 구조로 스택과 같다.

일반전 호출방식보다 크기를 줄이고 간단하게 작성할 수 있다.

---
### 재귀함수의 대표 팩토리얼 구현???
```python
def fact(n):
  if n == 0:
    return 0
  elif n == 1:
    return 1
  return n * fact(n-1)
```
근데 사실 펙토리얼은 재귀로 실제로는 구현하지 않는다고 한다!

---
### 재귀함수의 대표 피보나치 구현???
```python
def fibo(n):
  if n <= 1
  return n

  return fibo(n-2) + fibo(n-1)
```
얘도 사실 실제로는 재귀로 구현하지 않는다고 한다...!

---
### 재귀호출의 최대깊이
보통은 재귀함수의 호출횟수는 900 ~ 1000번 정도로 제한되어 있다.<br>
제한을 늘릴 수는 있지만..

만약 재귀 호출의 횟수가 크다면 다른 접근을 생각해 보는 것이 좋다.

---
### Memoization
위에 재귀함수로 구현한 피보나치는 엄청난 중복 호출이 존재한다는 문제점이 있다.

메모이제이션은 프로그램이 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 계산하지 않도록 하여 전체 실행속도를 빠르게 하는 기술이다.<br>
동적 계획법(DP)의 핵심!!

### Memoization 을 이용한 피보나치 구현
```python
def fibo1(n):
    if memo[n] == -1:
        memo[n] = fibo1(n-1) + fibo1(n-1)
    return memo[n]

memo = [-1]*101
memo[0] = 0
memo[1] = 1
```
속도차이가 매우매우매우심하다<br>
메모이제이션을 안쓰면 34쯤에서 벌써 느려지는게 보임

