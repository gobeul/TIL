# 카운팅 정렬 _ Counting sort

비교연산을 사용하지 않는 정렬로

시간 복잡도는 O(n + k) 이다. 여기서 k는 데이터의 최댓값을 나타낸다.<br>
데이터의 최대값이 클 수록 느려지지만 크지만 않다면 O(n) 의 시간으로 정렬이 가능하다.

즉, 숫자의 범위가 좁은 범위에서 효과적인 방법이다.

### 과정
1. 주어진 배열(arr)외에 리스트 2개 준비한다.(c, s) 
2. c는 배열안에 숫자들을 중복된 숫자만큼 카운팅하는 배열로 그 길이는 최대 값 (K+1) 이다. k+1 인 이유는 인덱스를 숫자에 맞춰주기 위함이다.
3. s는 정렬된 배열이 들어갈 리스트로써 길이는 당연히 arr과 같다.
4. c 작성후에 누적합으로 인덱스의 값을 바꾸어 준다.
5. c 가 누적 합이기 때문에 인덱스 K (가장 높은 숫자)는 가장 큰 숫자가 들어 있을 것이다.
6. arr 의 마지막 부터 역순으로 (왜?????) 숫자를 꺼내서(v) c[v] 값(cv)을 찾고, cv 에서 1을 뺸다음 (cv -= 1) s[cv]에 v를 집어넣는다.

### 구현
```python
def CS(arr, n): # n은 리스트 길이
    c = [0] * (n+1) # 카운팅 배열
    s = [0] * n     # 정렬된 배열

    for i in arr: # 숫자 카운팅하여 배열만들기
        c[i] += 1
    
    for i in range(1, n+1): # c리스트 누적합으로 만들기
        c[i] += c[i-1]

    for i in range(n-1, -1, -1): # arr의 역순부터 값을 빼서 (역순?? 왜??)
        c[arr[i]] -= 1
        s[c[arr[i]]] = arr[i]

    return s
```