# 비트연산자
1. & : 비트 단위로 AND 연산을 한다.
2. | : 비트 단위로 OR 연산을 한다.
3. << : 피연산자의 비트열을 왼쪽으로 이동시킨다.
4. .>> : 피연산자의 비트열을 오른쪽으로 이동시킨다.


1 << n : 1을 n번 왼쪽으로 옯겨라! 1번 옮겨질때마다 2씩 곱해진다.<br>
num1 << num2 == 피연산자(num1)를 num2 칸 왼쪽으로 옮긴다는 뜻!!<br>
```python
num1 = 1 # 1을 비트로 바꿔보면 0000 0000 0000 0001 이다.
num2 = 3

1 << 3 # 1을 왼쪽으로 3칸 옮긴다.
## 즉 0000 0001 이 0000 1000 이된다. 이는 8과 같다.(2**3)
### 다시말해 피연산자가 1일 때 1 << n 은 2**n 을 의미한다.
```

```python
# 0001 = 1
# 0010 = 2

# 즉 1 << n 은 2**n 이라고 할 수 있다.
```

<br>
i & (1 << j) : i의 j 번째 비트가 1인지 아닌지 검사한다.

```python
"""
# 1001 & 1010 = 1000 이다.

# 1 << j 는 2**j , 즉 j번 비트를 의미함
# 그러므로 i & (1 << j) 실행시 i비트의 j번자리가 0 이면 결과는 0000 이고
# j 번자리가 1이라면 00..1..00 이된다! = 2**j
"""
```


모든 부분 집합의 경우의 수를 구하는 방법 = 거의 공식처럼 암기해도 된다함. ( 공집합 포함임. )
```python
arr = [3, 6, 7, 1, 5, 4]
n = len(arr)

for i in range(1<<n):
  for j in range(n):
    if i & (1 << j):
      print(arr[j], end=", ")
  print()
print()
```